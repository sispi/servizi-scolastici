/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package it.filippetti.ks.api.bpm.service;

import it.filippetti.ks.api.bpm.command.callback.NotifyOnErrorCommandCallback;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import javax.annotation.PreDestroy;
import org.kie.api.executor.CommandContext;
import org.kie.api.executor.ErrorInfo;
import org.kie.api.executor.RequestInfo;
import org.kie.api.executor.STATUS;
import org.kie.api.runtime.query.QueryContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;

/**
 *
 * @author marco.mazzocchetti
 */
public class ExecutorService 
    implements org.kie.api.executor.ExecutorService {

    private static final Logger log = LoggerFactory.getLogger(ExecutorService.class);
    
    private final org.kie.api.executor.ExecutorService delegate;

    public ExecutorService(org.kie.api.executor.ExecutorService delegate) {
        this.delegate = delegate;
    }
    
    @EventListener(ApplicationReadyEvent.class)    
    public void startup() {        
        log.info("Starting executor service");
        delegate.init();;
    }    

    @PreDestroy
    public void shutdown() {
        log.info("Shutting down executor service");
        delegate.destroy();
    }
    
    @Override
    public int clearAllRequests() {
        return delegate.clearAllRequests();
    }

    @Override
    public int clearAllErrors() {
        return delegate.clearAllErrors();
    }

    @Override
    public Long scheduleRequest(String commandName, CommandContext ctx) {
        ctx.setData("commandName", commandName);
        // workaround to set a callback for error notification on async executions generated by jbpm
        // @see org.jbpm.workflow.instance.node.AsyncEventNodeInstance.internalTrigger()
        if (ctx.getData("callbacks") == null) {
            ctx.setData("callbacks", NotifyOnErrorCommandCallback.class.getName());
        }
        // fix jbpm bug that modifies context before execution and breaks our node retry feature
        // @see: org.jbpm.executor.impl.ExecutorImpl.scheduleRequest() line 355
        if (ctx.getData("retryDelay") != null && ctx.getData("retryDelay") instanceof List) {
            ctx.setData("retryDelay", ((List) ctx.getData("retryDelay")).get(0).toString());
        }
        return delegate.scheduleRequest(commandName, ctx);
    }

    @Override
    public void cancelRequest(Long requestId) {
        delegate.cancelRequest(requestId);
    }

    @Override
    public void init() {
        delegate.init();
    }

    @Override
    public void destroy() {
        delegate.destroy();
    }

    @Override
    public boolean isActive() {
        return delegate.isActive();
    }

    @Override
    public int getInterval() {
        return delegate.getInterval();
    }

    @Override
    public void setInterval(int waitTime) {
        delegate.setInterval(waitTime);
    }

    @Override
    public int getRetries() {
        return delegate.getRetries();
    }

    @Override
    public void setRetries(int defaultNroOfRetries) {
        delegate.setRetries(defaultNroOfRetries);
    }

    @Override
    public int getThreadPoolSize() {
        return delegate.getThreadPoolSize();
    }

    @Override
    public void setThreadPoolSize(int nroOfThreads) {
        delegate.setThreadPoolSize(nroOfThreads);
    }

    @Override
    public TimeUnit getTimeunit() {
        return delegate.getTimeunit();
    }

    @Override
    public void setTimeunit(TimeUnit timeunit) {
        delegate.setTimeunit(timeunit);
    }

    @Override
    public List<RequestInfo> getPendingRequestById(Long id) {
        return delegate.getPendingRequestById(id);
    }

    @Override
    public Long scheduleRequest(String commandName, Date date, CommandContext ctx) {
        ctx.setData("commandName", commandName);
        if (ctx.getData("callbacks") == null) {
            ctx.setData("callbacks", NotifyOnErrorCommandCallback.class.getName());
        }
        return delegate.scheduleRequest(commandName, date, ctx);
    }

    @Override
    public RequestInfo getRequestById(Long requestId) {
        return delegate.getRequestById(requestId);
    }

    @Override
    public List<ErrorInfo> getErrorsByRequestId(Long requestId) {
        return delegate.getErrorsByRequestId(requestId);
    }

    @Override
    public List<RequestInfo> getRequestsByBusinessKey(String businessKey, QueryContext queryContext) {
        return delegate.getRequestsByBusinessKey(businessKey, queryContext);
    }

    @Override
    public List<RequestInfo> getRequestsByCommand(String command, QueryContext queryContext) {
        return delegate.getRequestsByCommand(command, queryContext);
    }

    @Override
    public List<RequestInfo> getQueuedRequests(QueryContext queryContext) {
        return delegate.getQueuedRequests(queryContext);
    }

    @Override
    public List<RequestInfo> getCompletedRequests(QueryContext queryContext) {
        return delegate.getCompletedRequests(queryContext);
    }

    @Override
    public List<RequestInfo> getInErrorRequests(QueryContext queryContext) {
        return delegate.getInErrorRequests(queryContext);
    }

    @Override
    public List<RequestInfo> getCancelledRequests(QueryContext queryContext) {
        return delegate.getCancelledRequests(queryContext);
    }

    @Override
    public List<ErrorInfo> getAllErrors(QueryContext queryContext) {
        return delegate.getAllErrors(queryContext);
    }

    @Override
    public List<RequestInfo> getAllRequests(QueryContext queryContext) {
        return delegate.getAllRequests(queryContext);
    }

    @Override
    public List<RequestInfo> getRequestsByStatus(List<STATUS> statuses, QueryContext queryContext) {
        return delegate.getRequestsByStatus(statuses, queryContext);
    }

    @Override
    public List<RequestInfo> getPendingRequests(QueryContext queryContext) {
        return delegate.getPendingRequests(queryContext);
    }

    @Override
    public List<RequestInfo> getRunningRequests(QueryContext queryContext) {
        return delegate.getRunningRequests(queryContext);
    }

    @Override
    public List<RequestInfo> getFutureQueuedRequests(QueryContext queryContext) {
        return delegate.getFutureQueuedRequests(queryContext);
    }

    @Override
    public List<RequestInfo> getRequestsByBusinessKey(String businessKey, List<STATUS> statuses, QueryContext queryContext) {
        return delegate.getRequestsByBusinessKey(businessKey, statuses, queryContext);
    }

    @Override
    public List<RequestInfo> getRequestsByCommand(String command, List<STATUS> statuses, QueryContext queryContext) {
        return delegate.getRequestsByCommand(command, statuses, queryContext);
    }

    @Override
    public List<RequestInfo> getRequestsByDeployment(String deploymentId, List<STATUS> statuses, QueryContext queryContext) {
        return delegate.getRequestsByDeployment(deploymentId, statuses, queryContext);
    }

    @Override
    public List<RequestInfo> getRequestsByProcessInstance(Long processInstanceId, List<STATUS> statuses, QueryContext queryContext) {
        return delegate.getRequestsByProcessInstance(processInstanceId, statuses, queryContext);
    }

    @Override
    public void updateRequestData(Long requestId, Map<String, Object> data) {
        delegate.updateRequestData(requestId, data);
    }
}
